### ac840模拟散列表

### 题目描述
维护一个集合，支持如下几种操作：

“I x”，插入一个数x；
“Q x”，询问数x是否在集合中出现过；
现在要进行N次操作，对于每个询问操作输出对应的结果。
#### 样例
**输入**
```
5
I 1
I 2
I 3
Q 2
Q 5
```
**输出**
```
Yes
No
```

----------
#### 开放寻址法
```c++
/*
开放寻址法 只开一个数组 一般为题目给的2~3倍 

添加 如果冲突则往后移动一个坑位查看冲突嘛，如果冲突继续后移
查找 类似添加，找不到后移一个
删除 开一个bool数组 
*/
#include<cstring>
#include<iostream>

using namespace std;

const int N = 200003; //经验值一般大2~3倍
const int null = 0x3f3f3f3f;//作为这个位置上没有数字的标记

int h[N];
//如果 x映射位置不为空返回x的下标，如果冲突，返回解决冲突后的下标所在的位置
int find(int x){
    int t = (x % N + N) % N;
    
    while(h[t] != null && h[t] != x){
        t ++;
        if(t == N) t = 0; //如果遍历到头了 从头开始循环
    }
    return t;
}

int main(){
    
    
    memset(h, 0x3f, sizeof h);
    
    int n;
    
    scanf("%d", &n);
    
    while(n --){
        char op[2];
        int x;
        scanf("%s%d", op, &x);
        if(*op == 'I') h[find(x)] = x;
        else {
            if(h[find(x)] == null) puts("No");
            else puts("Yes");
        }
    }
    return 0;
}
```


#### 拉链法
```c++
#include<iostream>
#include<cstring>

using namespace std;

const int N = 100003; //大于100000的第一个质数

int h[N], e[N], ne[N], idx;

void insert(int x){
    //c++中 负数 取模还是负数 所以要先取模在＋N在取模
    int k = (x % N + N) % N;
    e[idx] = x;
    ne[idx] = h[k]; // h[k] 链上第一个位置的
    h[k] = idx ++;//在链表中插入一个结点
}

bool find(int x){
    int k = (x % N + N) % N;
    //遍历单链表
    for(int i = h[k]; i != -1; i = ne[i]){
        if(e[i] == x){
            return true;
        }
    }
    return false;
}




int main(){
    int n;
    scanf("%d", &n);
    //初始化拉链数组
    memset(h, - 1, sizeof h);
    
    while(n -- ){
        char op[2];
        int x;
        //防止输入错误用字符数组好
        scanf("%s%d", op, &x);
        if(*op == 'I') insert(x);
        else{
            if(find(x)) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}
```