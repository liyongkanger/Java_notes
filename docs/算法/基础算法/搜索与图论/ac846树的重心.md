### ac846树的重心

### 题目描述
给定一颗树，树中包含n个结点（编号1~n）和n-1条无向边。

请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。

重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。


#### 样例
**输入**
```
9
1 2
1 7
1 4
2 8
2 5
4 3
3 9
4 6
```
**输出**
```
4
```
#### 树的模板
```
// 需要标记数组st[N],  遍历节点的每个相邻的便
void dfs(int u) {
    st[u] = true; // 标记一下，记录为已经被搜索过了，下面进行搜索过程
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (!st[j]) {
            dfs(j);
        }
    }
}
```

----------
树的深度优先遍历
```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;
//有向图存无向图每个结点最多2n-2条边
const int N = 100010, M = N * 2;

int n;
int h[N]; //邻接表存储存头
int e[M]; //存值
int ne[M]; //存列表的next值
int idx; //单链表指针
int ans = N;
bool st[N]; //记录结点是否为访问过 访问过为true

//将a的链表插入b a作为根
void add(int a, int b){
 e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// 结点为u的树有多少个结点包含u
int dfs(int u){
    
    st[u] = true;

    int size = 0, sum = 0;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (st[j]) continue;

        int s = dfs(j);//记录子树的节点数包含子树
        size = max(size, s); //记录最大连通子图的节点数
        sum += s; //以j为根的结点数
    }

    size = max(size, n - sum - 1); //不包含其他子树的最大连通子图的节点数
    ans = min(ans, size); //取最小

    return sum + 1;

}

//树的深度优先遍历
int main(){
    
     scanf("%d", &n);
    //初始化  -1表示尾结点
    memset(h, -1, sizeof h);
    // 题目n-1行数据
    //不存在环 只有 n - 1 条边
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }
    //可以选定任意一个结点
    dfs(1);

    printf("%d\n", ans);

    return 0;
    
}
```