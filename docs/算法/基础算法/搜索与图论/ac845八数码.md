### ac845八数码

### 题目描述
在一个3×3的网格中，1~8这8个数字和一个“x”恰好不重不漏地分布在这3×3的网格中。
一次只能移动一格(数字华容道)
```
1 2 3
x 4 6
7 5 8
```
转换为最终状态
```
1 2 3
4 5 6
7 8 x
```

#### 样例
**输入**
```
2  3  4  1  5  x  7  6  8 
```
**输出**
```
19
```

----------
#### 思路
1. 最小方案数 所以采用 bfs 使用队列考虑队列如何存状态   字符类型存成一维
2. 如何记录 状态改变的次数 用hashmap存 string int 存当前状态和次数
3. 如何做状态转移  一维数组到二维，状态改变后在恢复一维进行存储

```c++
#include<iostream>
#include<algorithm>
#include<unordered_map>
#include<queue>

using namespace std;
/*
两个难点： 1. 队列怎么存状态
           2.  如何记录状态的距离
           3. 如何做状态转移           
    1.字符串表示某种状态 
    2.dist 用字典map
    3. 恢复成3*3的样子，在转移 枚举上下左右  在恢复成字符串
    

*/
int bfs(string state){
    
    //宽搜队列
    queue<string> q;
    //存某种状态和初始状态转移到这种状态的次数 距离数组
    unordered_map<string, int> d;
    
    q.push(state);
    d[state] = 0;
    
    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, 1, 0, -1};
    //定义终点
    string end = "12345678x";
    while(q.size()){
        auto t = q.front();
        q.pop();
        
        if(t == end) return d[t];
        
        int distance = d[t];
        
        //状态转移
        //返回x的下标
        int k = t.find('x');
        //一维数组下标转换为二维数组的下标 公式
        int x = k / 3, y = k % 3;
        // 枚举4个位置的数
        for(int i = 0; i < 4; i ++){
            
            int a = x + dx[i], b = y + dy[i];
            
            if(a >= 0 && a < 3 && b >= 0 && b < 3){
                // 交换字符串中两个值 状态更新
                swap(t[a*3 + b], t[k]); //二维转换为一维坐标 a*3 + b
                //如果新的状态没有记录则更新距离 将新状态加入队列
                if(!d.count(t)){
                    d[t] = distance + 1;
                    q.push(t);
                }
                //恢复状态
                swap(t[a * 3 + b], t[k]);
            }
        }
    }
    return -1;
}

int main(){
    //定义初始状态
    string state;
    
    for(int i = 0; i < 9; i ++){
        char c;
        cin >> c;
        state += c;
    }
    
    cout << bfs(state) << endl;
    
    return  0;
}
```