#### 842. 排列数字

### 题目描述
给定一个整数n，将数字1~n排成一排，将会有很多种排列方法。

现在，请你按照字典序将所有的排列方法输出。

#### 样例
**输入**
```
3
```
**输出**
```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```
----------


#### 方法一 
```c++
#include<iostream>

using namespace std;

const int N = 10;
int n;
int path[N];

void dfs(int u, int state){
    //递归出口
    if(u == n){
        for(int i = 0; i < n; i ++) printf("%d ", path[i]);
        
        puts("");
        return ;
    }
    
    for(int i = 0; i < n; i ++){
        // state 查看二进制中 第 i 为是否为1 是则选中这个数
        //0 则不选这个数
        if(!(state >> i & 1)){
            path[u] = i + 1;
            //   state + (1 << i) 将state 的第 i 位置为 1表示选择这个数
            dfs(u + 1, state + (1 << i));
            /*
            为什么不用回复现场
            因为进入递归的数时state + (1 << i) 也就是在第i位的状态变了，所以尽管
            在递归完成后没有语句回复现场，但是state这个数一直没变，所以递归完成之前和以后状态一样
            */
        }
    }
    
}


int main(){
    cin >> n;
    
    dfs(0, 0);
    
    return 0;
}
```

#### 方法二
```c++
#include<iostream>

using namespace std;

int n;
const int N = 10;
int path[N]; //path[] 用于保存路径
bool st[N]; // 用于记录这个数字是否被用过

void dfs(int u){
    
    
    if(u == n) {
        for(int i = 0; i < n; i ++) cout << path[i] << ' ';
    
       cout << endl;
       return ;
    }
    
    for(int i = 1; i <= n; i ++){
        //如果i没有用过
        if(!st[i]){
        st[i] = true; // i 使用
        path[u] = i; //将第u个位置填上i
        dfs(u + 1); //递归到下一个位置
        st[i] = false; //恢复现场
        path[u] = 0; // 恢复现场
        }
    }
    
    
}

int main(){
    cin >> n;
    
    dfs(0);
    
    return 0;

}
```

