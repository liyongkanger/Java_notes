### lc31下一个排列

### 题目描述
实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间

#### 样例

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

----------

#### 思路
1. 给定数字序列重新排列成字典序列中下一个更大的排序
2. 上一句话的意思就是 从后往前找到第一个出现下降的地方 把这个数字与后面的某个比他大的数字交换然后将后面整理为升序


```c++
class Solution {
public:
   // 给定数字序列重新排列成字典序列中
// 下一个更大的排列
/*
  就是从后往前寻找第一个出现降的地方 把这个地方的数字与后边的某个比他大的数字交换，在把该位置之后整理为升序
*/
    void nextPermutation(vector<int>& nums) {
        
        int k = nums.size() - 1;
        //找到最后一个出现nums[k-1] < nums[k]的地方
        while(k > 0 && nums[k - 1] >= nums[k]) k --;
        //如果没有则改为 升序序列
        if(k <= 0){
            reverse(nums.begin(), nums.end());
        }else{
            //找到后面某个比k-1大的数
            int t = k;
            while(t < nums.size() && nums[t] > nums[k - 1]) t ++;
            //交换两个数
            swap(nums[t - 1], nums[k - 1]);
            //在改为升序
            reverse(nums.begin()+k, nums.end());
        }
    }
};
```