### lc22括号生成

### 题目描述
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合


#### 样例

```
输入：n = 3
输出：[
       "((()))",
       "(()())",
       "(())()",
       "()(())",
       "()()()"
     ]
```

----------

#### 思路：
1. 枚举所有情况出来 dfs  定义左右括号数和dfs过程状态
2. 在任意前缀中`(`的数 `>=` `)`的数量， 最终左右括号数相等
3. `lc` 左边的括号 `< n` 可以加入一个左括号
4. `rc` 右边括号数量 `< n` 且 `lc > rc`左边的括号大于左边的括号才能加入

```c++
class Solution {
public:
    //暴力枚举所有情况 dfs穷举优化
    /*
     n 个 () 输出合法方案

    结论：

     1.任意前缀中 '(' => ')'  2. 左右括号数量相等
     3. 数量为 c2n n  / n + 1
     满足 ( < n   
          ) < n && ( > )



    */

    //定义答案
    vector<string> ans;
            //括号数量   左括号数量  右边括号数量  遍历的状态
    void dfs(int n, int lc, int rc, string seq){
        //如果( == ) 就将遍历状态seq存入 ans
        if(lc == n && rc == n) ans.push_back(seq);
        else{
            // 如果左边括号 < n  递归下一个状态
            if(lc < n) dfs(n, lc + 1, rc, seq + "(");
            // 右边括号小于n 且左边括号大于右边括号
            if(rc < n && lc > rc ) dfs(n,lc, rc + 1, seq + ")");
        }
    }

    vector<string> generateParenthesis(int n) {
       dfs(n, 0, 0, "");
       return ans;
    }
};
```