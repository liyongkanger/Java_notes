### lc16最接近的三数之和

### 题目描述
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

#### 样例

```
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```

----------

#### 思路
1. 因为寻找与`target`最接近的三个数所以需要3个指针得出循环加双指针算法(需要排序)
2. 因为与target最接近，三个数的和可能比target大或者比target小所以分两种情况 `int s = nums[i] + nums[j] + nums[k]` 或者 比target 小 `int s = nums[i] + nums[j] + nums[k - 1]` 试探k指针指向的前一个数

```c++
class Solution {
public:
    /*
    给n个整数 和一个目标值target
    找出3个整数与target最接近 返回这三个数的和

    考虑两边的情况
    */
    int threeSumClosest(vector<int>& nums, int target) {
      //排序
      sort(nums.begin(), nums.end());
      //初始化为最大值 存差值 和 结果值
      pair<int, int> res(INT_MAX, INT_MAX);

      for(int i = 0; i < nums.size(); i ++){

          for(int j = i + 1, k = nums.size()-1; j < k; j ++ ){
              // 要满足 j < k 所以每次试探nums[k -1] 的数是否合适 避免越界
              // nums[i] + nums[j] + nums[k] >= target nums[i] + nums[j] + nums[k - 1] < target
              while(k - 1 > j && nums[i] + nums[j] + nums[k - 1] >= target) k --;
              int s = nums[i] + nums[j] + nums[k];
              // 求出最小差值
              res = min(res, make_pair(abs(s - target), s));
              //试探k前一个是否在部分里里 target 另外一部分
              if(k - 1 > j){
                  s = nums[i] + nums[j] + nums[k - 1];
                  res = min(res, make_pair(target - s, s));
              }
          }
      }
      return res.second;
    }
};
```